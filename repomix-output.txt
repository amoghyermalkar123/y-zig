This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-11T16:09:59.687Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  docs/
    addingText.md
    remoteUpdates.md
  replay/
    build.zig
    build.zig.zon
    main.zig
    raylib_backend.zig
    replay.zig
  block_store.zig
  doc.zig
  global_clock.zig
  main.zig
  search_marker.zig
  test.zig
  update.zig
.gitignore
build.zig
build.zig.zon
README.md
test_runner.zig

================================================================
Repository Files
================================================================

================
File: src/docs/addingText.md
================
## Adding text
- check text needs a split of existing block
- split blocks and create necessary blocks
- neighbors and origin repairing
- iterate and insert each new block

================
File: src/docs/remoteUpdates.md
================
## How remote updates are read and integrated in local document
- get transaction
- get the underlying struct store
- de serialize the binary update we receive from a peer
- start integrating per-client block list
- retry previously un-integrated blocks into block store
- un-integrated blocks are added to pending queue and will be retried in the next integration call
- same for delete set

================
File: src/replay/build.zig
================
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});

    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "replay",
        .root_source_file = b.path("./main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // Setup clay dependency.
    const clay_dep = b.dependency("clay", .{
        .target = target,
        .optimize = optimize,
    });
    const clay = clay_dep.module("clay");
    exe.root_module.addImport("clay", clay);

    // Setup Raylib dep.
    const raylib = b.dependency("raylib-zig", .{
        .target = target,
        .optimize = optimize,
    });
    exe.root_module.addImport("raylib", raylib.module("raylib"));

    const raylib_artifact = raylib.artifact("raylib");
    exe.linkLibrary(raylib_artifact);

    // This declares intent for the executable to be installed into the
    // standard location when the user invokes the "install" step (the default
    // step when running `zig build`).
    b.installArtifact(exe);

    // This *creates* a Run step in the build graph, to be executed when another
    // step is evaluated that depends on it. The next line below will establish
    // such a dependency.
    const run_cmd = b.addRunArtifact(exe);

    // By making the run step depend on the install step, it will be run from the
    // installation directory rather than directly from within the cache directory.
    // This is not necessary, however, if the application depends on other installed
    // files, this ensures they will be present and in the expected location.
    run_cmd.step.dependOn(b.getInstallStep());

    // This allows the user to pass arguments to the application in the build
    // command itself, like this: `zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    // This creates a build step. It will be visible in the `zig build --help` menu,
    // and can be selected like this: `zig build run`
    // This will evaluate the `run` step rather than the default, which is "install".
    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);
}

================
File: src/replay/build.zig.zon
================
.{
    .name = "replay",

    .version = "0.0.0",

    .dependencies = .{
        .clay = .{
            .url = "git+https://github.com/Gota7/zig-clay#fc762b8366af0235c8fe2f0a837c41a2acbdfd08",
            .hash = "1220f6788bef883e4859c943d42737c495505c524d39c132e10226d604b2f99f895d",
        },
        .@"raylib-zig" = .{
            .url = "git+https://github.com/Not-Nik/raylib-zig?ref=devel#4e05ee5a3f1384700f62d4ad6545d2dd48f72ec1",
            .hash = "12203d859a74737cefe2e1d345a612b59fd372030cc749f9950ef418e7e0cb7d15e5",
        },
    },

    .paths = .{
        "build.zig",
        "build.zig.zon",
        "src",
    },
}

================
File: src/replay/main.zig
================
const std = @import("std");
const cl = @import("clay");
const rl = @import("raylib");
const clayrl = @import("raylib_backend.zig");
const ID = @import("./replay.zig").ID;
const Replay = @import("./replay.zig").Replay;
const InternalEventType = @import("./replay.zig").InternalEventType(ID);

const font_id_body_16: u16 = 0;

const Colors = struct {
    const Color = struct {
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    };

    // Base color definitions
    const white = Color{ .r = 255, .g = 255, .b = 255, .a = 255 };
    const red = Color{ .r = 255, .g = 0, .b = 0, .a = 255 };

    // Convert to Clay color type
    fn toClay(color: Color) cl.Color {
        return .{
            .r = color.r,
            .g = color.g,
            .b = color.b,
            .a = color.a,
        };
    }

    // Convert to Raylib color type
    fn toRaylib(color: Color) rl.Color {
        return .{
            .r = @intFromFloat(color.r),
            .g = @intFromFloat(color.g),
            .b = @intFromFloat(color.b),
            .a = @intFromFloat(color.a),
        };
    }
};

// Error handling function for Clay
fn handleClayError(error_data: cl.ErrorData(void)) void {
    std.debug.print("Clay error: {s}\n", .{error_data.error_text});
}

// Track time and squares
var elapsed_time: f32 = 0;
var num_squares: usize = 0;

pub fn update(delta_time: f32) void {
    elapsed_time += delta_time;

    // Add new square every second
    if (elapsed_time >= 1.0) {
        elapsed_time = 0;
        num_squares += 1;
    }
}

pub fn main() !void {
    // Initialize raylib window
    const screen_width = rl.getScreenWidth();
    const screen_height = rl.getScreenHeight();
    rl.initWindow(screen_width, screen_height, "Clay Rectangle Example");
    defer rl.closeWindow();

    // Set target FPS
    rl.setTargetFPS(60);

    // Create memory arena for Clay
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize Clay with minimum required memory
    const mem_size = cl.minMemorySize();
    const memory = try allocator.alloc(u8, mem_size);
    defer allocator.free(memory);

    // Create Clay arena and initialize
    const arena = cl.createArenaWithCapacityAndMemory(memory);
    cl.initialize(arena, .{ .width = @floatFromInt(screen_width), .height = @floatFromInt(screen_height) }, void, .{ .handler_function = handleClayError, .user_data = undefined });

    cl.setMeasureTextFunction(clayrl.measureText);
    clayrl.fonts = std.ArrayList(clayrl.Font).init(std.heap.c_allocator);
    defer clayrl.fonts.?.deinit();
    try clayrl.fonts.?.append(.{
        .font = rl.loadFontEx("/home/amogh/tinkers/clay-ui-tinkers/resources/Roboto-Regular.ttf", 48, null),
        .id = font_id_body_16,
    });
    rl.setTextureFilter(clayrl.fonts.?.items[font_id_body_16].font.texture, .bilinear);
    defer rl.unloadFont(clayrl.fonts.?.items[font_id_body_16].font);

    // cl.C.Clay_SetDebugModeEnabled(true);

    // Create text arena for rendering
    var text_arena = std.heap.ArenaAllocator.init(allocator);
    defer text_arena.deinit();

    var alloc = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer alloc.deinit();

    var internal_events_list = std.ArrayList(InternalEventType).init(alloc.allocator());
    var r = Replay.init(&internal_events_list);
    try r.parse_log(alloc.allocator(), "/home/amogh/projects/y-zig/test.log");

    // Main game loop
    while (!rl.windowShouldClose()) {
        cl.setLayoutDimensions(.{
            .width = @floatFromInt(rl.getScreenWidth()),
            .height = @floatFromInt(rl.getScreenHeight()),
        });
        // Begin drawing
        rl.beginDrawing();
        defer rl.endDrawing();

        // Clear background
        rl.clearBackground(Colors.toRaylib(Colors.white));

        // BEGIN
        const layout = cl.beginLayout();
        thing();
        // END
        var commands = layout.end();

        // Render the Clay commands using Clay's raylib backend
        clayrl.render(&commands, &text_arena);
        const delta = 1.0 / 60.0; // 60 FPS
        update(delta);
    }
}

fn render_button(text: []const u8) void {
    if (cl.child(&.{
        cl.layout(.{
            .padding = .{ .x = 16, .y = 5 },
        }),
        cl.rectangle(
            .{
                .color = .{ .r = 140, .g = 140, .b = 140, .a = 255 },
                .corner_radius = .{ .top_left = 5, .top_right = 5, .bottom_left = 5, .bottom_right = 5 },
            },
        ),
    })) |btn| {
        cl.text(
            text,
            .{
                .font_id = font_id_body_16,
                .font_size = 24,
                .text_color = .{ .r = 255, .g = 255, .b = 255, .a = 255 },
            },
        );
        defer btn.end();
    }
}

fn thing() void {
    const layout_expand = .{
        .width = cl.sizingGrow(.{}),
        .height = cl.sizingGrow(.{}),
    };

    const content_bg_config = .{
        .color = .{ .r = 90, .g = 90, .b = 90, .a = 255 },
        .corner_radius = .{ .top_left = 8, .top_right = 8, .bottom_left = 8, .bottom_right = 8 },
    };

    if (cl.child(&.{ cl.id("app"), cl.layout(
        .{},
    ) })) |container| {
        defer container.end();
        if (cl.child(&.{
            cl.id("outer-container"),
            cl.rectangle(.{ .color = .{ .r = 44, .g = 41, .b = 51, .a = 255 } }),
            cl.layout(.{
                .sizing = .{
                    .width = cl.sizingGrow(.{
                        .min = @floatFromInt(rl.getScreenWidth()),
                    }),
                    .height = cl.sizingGrow(.{
                        .min = @floatFromInt(rl.getScreenHeight()),
                    }),
                },
                .padding = .{ .x = 16, .y = 16 },
                .layout_direction = .top_to_bottom,
                .child_gap = 16,
            }),
        })) |sq| {
            defer sq.end();
            if (cl.child(&.{
                cl.id("header-bar"),
                cl.rectangle(content_bg_config),
                cl.layout(.{
                    .sizing = .{
                        .width = cl.sizingGrow(.{}),
                        .height = cl.sizingFixed(60),
                    },
                    .padding = .{
                        .x = 16,
                        .y = 8,
                    },
                    .child_gap = 16,
                    .child_alignment = .{
                        .y = .center,
                    },
                }),
            })) |header| {
                defer header.end();

                render_button("Play");
                render_button("Pause");
                render_button("Resume");
            }

            if (cl.child(&.{
                cl.id("lower-content"),
                cl.layout(.{
                    .sizing = layout_expand,
                    .child_gap = 16,
                }),
            })) |lowerContent| {
                defer lowerContent.end();

                // sidebar
                if (cl.child(&.{
                    cl.id("sidebar"),
                    cl.layout(.{
                        .sizing = .{ .width = cl.sizingFixed(250), .height = cl.sizingGrow(.{}) },
                    }),
                    cl.rectangle(content_bg_config),
                })) |sidebar| {
                    defer sidebar.end();
                }

                // main content
                if (cl.child(&.{
                    cl.id("main-content"),
                    cl.layout(.{
                        .sizing = layout_expand,
                    }),
                    cl.rectangle(content_bg_config),
                })) |mainContent| {
                    defer mainContent.end();
                    render_box();
                }
            }
        }
    }
}

fn render_box() void {
    // Container for squares
    if (cl.child(&.{ cl.id("squares-container"), cl.layout(.{
        .layout_direction = .left_to_right,
        .child_gap = 10,
        .padding = .{ .x = 10, .y = 10 },
    }) })) |container| {
        defer container.end();

        // Draw current number of squares
        var i: usize = 0;
        while (i < num_squares) : (i += 1) {
            if (cl.child(&.{
                cl.idi("square", @intCast(i)),
                cl.rectangle(.{
                    .color = .{ .r = 255, .g = 0, .b = 0, .a = 255 },
                }),
                cl.layout(.{
                    .sizing = .{
                        .width = cl.sizingFixed(50),
                        .height = cl.sizingFixed(50),
                    },
                }),
            })) |square| {
                defer square.end();
            }
        }
    }
}

pub const Cmds = struct {};
fn readLog() void {}
fn cmds() void {}

================
File: src/replay/raylib_backend.zig
================
const clay = @import("clay");
const raylib = @import("raylib");
const std = @import("std");

/// Font wrapper for raylib renderer.
pub const Font = struct {
    /// Font ID for clay.
    id: u32,
    /// Raylib font information.
    font: raylib.Font,
};

/// Global font list.
pub var fonts: ?std.ArrayList(Font) = null;

/// Convert a clay color to a raylib one.
/// * `color` - Color to convert to a raylib one.
pub fn clayColorToRaylib(color: clay.Color) raylib.Color {
    return .{
        .r = @intFromFloat(color.r),
        .g = @intFromFloat(color.g),
        .b = @intFromFloat(color.b),
        .a = @intFromFloat(color.a),
    };
}

/// Callback for clay to get the dimensions of text data.
/// * `text` - Input text to measure.
/// * `config` - Configuration properties of the input text.
pub fn measureText(text: []const u8, config: clay.TextElementConfig) clay.Dimensions {
    if (fonts == null) {
        std.debug.print("Global font list has not been initialized.\n", .{});
        return .{};
    }
    if (config.font_id >= fonts.?.items.len) {
        std.debug.print("Font ID {d} is invalid.\n", .{config.font_id});
        return .{};
    }

    var text_size = clay.Dimensions{ .width = 0, .height = 0 };

    var max_text_width: f32 = 0;
    var line_text_width: f32 = 0;

    const text_height = config.font_size;
    const font = fonts.?.items[config.font_id].font;
    const scale_factor = @as(f32, @floatFromInt(config.font_size)) / @as(f32, @floatFromInt(font.baseSize));

    for (0..text.len) |ind| {
        if (text[ind] == '\n') {
            max_text_width = @max(max_text_width, line_text_width);
            line_text_width = 0;
            continue;
        }
        const index = text[ind] - 32;
        if (font.glyphs[index].advanceX != 0) {
            line_text_width += @floatFromInt(font.glyphs[index].advanceX);
        } else {
            line_text_width += font.recs[index].width + @as(f32, @floatFromInt(font.glyphs[index].offsetX));
        }
    }

    max_text_width = @max(max_text_width, line_text_width);

    text_size.width = max_text_width * scale_factor;
    text_size.height = @floatFromInt(text_height);

    return text_size;
}

/// Initialize the clay-raylib renderer with the given configuration flags and window info.
/// * `width` - Initial window width.
/// * `height` - Initial window height.
/// * `title` - Initial window title.
/// * `config_flags` - Configuration flags for the window.
pub fn initialize(width: i32, height: i32, title: [*:0]const u8, config_flags: raylib.ConfigFlags) void {
    raylib.setConfigFlags(config_flags);
    raylib.initWindow(width, height, title);
}

/// Handle rendering a clay command list.
/// * `commands` - Render commands provided from `.end()` for a `Layout`.
/// * `text_arena` - Arena to allocate text from.
pub fn render(commands: *clay.RenderCommandArray, text_arena: *std.heap.ArenaAllocator) void {
    var iter = commands.iter();
    while (iter.next()) |command| {
        switch (command.config) {
            .none => {},
            .text => |text| {
                const allocator = text_arena.allocator();
                const cloned = allocator.allocSentinel(u8, command.text.?.len, 0) catch unreachable;
                defer _ = text_arena.reset(.retain_capacity);
                std.mem.copyForwards(u8, cloned, command.text.?);
                const font = fonts.?.items[text.font_id].font;
                raylib.drawTextEx(
                    font,
                    cloned,
                    .{ .x = command.bounding_box.x, .y = command.bounding_box.y },
                    @floatFromInt(text.font_size),
                    @floatFromInt(text.letter_spacing),
                    clayColorToRaylib(text.text_color),
                );
            },
            .image => |image| {
                const image_texture = @as(*raylib.Texture2D, @ptrCast(@alignCast(image.image_data))).*;
                raylib.drawTextureEx(
                    image_texture,
                    .{ .x = command.bounding_box.x, .y = command.bounding_box.y },
                    0,
                    command.bounding_box.width / @as(f32, @floatFromInt(image_texture.width)),
                    raylib.Color.white,
                );
            },
            .scissor_start => {
                raylib.beginScissorMode(
                    @intFromFloat(@round(command.bounding_box.x)),
                    @intFromFloat(@round(command.bounding_box.y)),
                    @intFromFloat(@round(command.bounding_box.width)),
                    @intFromFloat(@round(command.bounding_box.height)),
                );
            },
            .scissor_end => {
                raylib.endScissorMode();
            },
            .rectangle => |rect| {
                if (rect.corner_radius.top_left > 0) {
                    const radius = rect.corner_radius.top_left * 2 / (if (command.bounding_box.width > command.bounding_box.height) command.bounding_box.height else command.bounding_box.width);
                    raylib.drawRectangleRounded(
                        .{
                            .x = command.bounding_box.x,
                            .y = command.bounding_box.y,
                            .width = command.bounding_box.width,
                            .height = command.bounding_box.height,
                        },
                        radius,
                        8,
                        clayColorToRaylib(rect.color),
                    );
                } else {
                    raylib.drawRectangle(
                        @intFromFloat(command.bounding_box.x),
                        @intFromFloat(command.bounding_box.y),
                        @intFromFloat(command.bounding_box.width),
                        @intFromFloat(command.bounding_box.height),
                        clayColorToRaylib(rect.color),
                    );
                }
            },
            .border => |border| {

                // Left border.
                if (border.left.width > 0) {
                    raylib.drawRectangle(
                        @intFromFloat(@round(command.bounding_box.x)),
                        @intFromFloat(@round(command.bounding_box.y + border.corner_radius.top_left)),
                        @intCast(border.left.width),
                        @intFromFloat(@round(command.bounding_box.height - border.corner_radius.top_left - border.corner_radius.bottom_left)),
                        clayColorToRaylib(border.left.color),
                    );
                }

                // Right border.
                if (border.right.width > 0) {
                    raylib.drawRectangle(
                        @as(i32, @intFromFloat(@round(command.bounding_box.x + command.bounding_box.width))) - @as(i32, @intCast(border.right.width)),
                        @intFromFloat(@round(command.bounding_box.y + border.corner_radius.top_right)),
                        @intCast(border.right.width),
                        @intFromFloat(@round(command.bounding_box.height - border.corner_radius.top_right - border.corner_radius.bottom_right)),
                        clayColorToRaylib(border.right.color),
                    );
                }

                // Top border.
                if (border.top.width > 0) {
                    raylib.drawRectangle(
                        @intFromFloat(@round(command.bounding_box.x + border.corner_radius.top_left)),
                        @intFromFloat(@round(command.bounding_box.y)),
                        @intFromFloat(@round(command.bounding_box.width - border.corner_radius.top_left - border.corner_radius.top_right)),
                        @intCast(border.top.width),
                        clayColorToRaylib(border.top.color),
                    );
                }

                // Bottom border.
                if (border.bottom.width > 0) {
                    raylib.drawRectangle(
                        @intFromFloat(@round(command.bounding_box.x + border.corner_radius.bottom_left)),
                        @as(i32, @intFromFloat(@round(command.bounding_box.y + command.bounding_box.height))) - @as(i32, @intCast(border.bottom.width)),
                        @intFromFloat(@round(command.bounding_box.width - border.corner_radius.bottom_left - border.corner_radius.bottom_right)),
                        @intCast(border.bottom.width),
                        clayColorToRaylib(border.bottom.color),
                    );
                }

                // Rings.
                if (border.corner_radius.top_left > 0) {
                    raylib.drawRing(
                        .{
                            .x = @round(command.bounding_box.x + border.corner_radius.top_left),
                            .y = @round(command.bounding_box.y + border.corner_radius.top_left),
                        },
                        @round(border.corner_radius.top_left) - @as(f32, @floatFromInt(border.top.width)),
                        border.corner_radius.top_left,
                        180,
                        270,
                        10,
                        clayColorToRaylib(border.top.color),
                    );
                }
                if (border.corner_radius.top_right > 0) {
                    raylib.drawRing(
                        .{
                            .x = @round(command.bounding_box.x + command.bounding_box.width - border.corner_radius.top_right),
                            .y = @round(command.bounding_box.y + border.corner_radius.top_right),
                        },
                        @round(border.corner_radius.top_right) - @as(f32, @floatFromInt(border.top.width)),
                        border.corner_radius.top_right,
                        270,
                        360,
                        10,
                        clayColorToRaylib(border.top.color),
                    );
                }
                if (border.corner_radius.bottom_left > 0) {
                    raylib.drawRing(
                        .{
                            .x = @round(command.bounding_box.x + border.corner_radius.bottom_left),
                            .y = @round(command.bounding_box.y + command.bounding_box.height - border.corner_radius.bottom_left),
                        },
                        @round(border.corner_radius.bottom_left) - @as(f32, @floatFromInt(border.top.width)),
                        border.corner_radius.bottom_left,
                        90,
                        180,
                        10,
                        clayColorToRaylib(border.bottom.color),
                    );
                }
                if (border.corner_radius.bottom_right > 0) {
                    raylib.drawRing(
                        .{
                            .x = @round(command.bounding_box.x + command.bounding_box.width - border.corner_radius.bottom_right),
                            .y = @round(command.bounding_box.y + command.bounding_box.height - border.corner_radius.bottom_right),
                        },
                        @round(border.corner_radius.bottom_right) - @as(f32, @floatFromInt(border.bottom.width)),
                        border.corner_radius.bottom_right,
                        0.1,
                        90,
                        10,
                        clayColorToRaylib(border.bottom.color),
                    );
                }
            },
            .custom => {
                std.debug.print("Unsupported render command \"Custom\"\n", .{});
            },
        }
    }
}

================
File: src/replay/replay.zig
================
const std = @import("std");

pub const ID = struct {
    clock: u64,
    client: u64,

    pub fn id(clock: u64, client: u64) ID {
        return ID{
            .clock = clock,
            .client = client,
        };
    }
};

pub const LogLevel = enum {
    debug,
    info,
    warn,
    err,

    pub fn asString(self: LogLevel) []const u8 {
        return switch (self) {
            .debug => "DEBUG",
            .info => "INFO",
            .warn => "WARN",
            .err => "ERROR",
        };
    }
};

pub const EventType = enum {
    create,
    delete,
    // block
    marker,
    neighbor_reconnection,
    // state vector events
    state_vector_update,
    // integration
    ibo_update,
    ci_update,
    // integration
    integration_start,
    conflict_detected,
    conflict_resolved,
    integration_end,
    // generic
    generic,
};

pub fn BlockLogEventType(comptime T: type) type {
    return struct {
        event_type: EventType,
        block_id: T,
        content: []const u8,
        left_origin: ?T,
        right_origin: ?T,
        left: ?T,
        right: ?T,
        timestamp: i64,
        msg: []const u8,
    };
}

pub fn IBOLogEventType(comptime T: type) type {
    return struct {
        event_type: EventType = .ibo_update,
        block_id: T,
        timestamp: i64,
    };
}

pub fn CILogEventType(comptime T: type) type {
    return struct {
        event_type: EventType = .ci_update,
        block_id: T,
        timestamp: i64,
    };
}

pub fn IntegrationLogEventType(comptime T: type) type {
    return struct {
        phase: EventType, // "start", "conflict_detected", "resolution_step", "complete"
        block_id: T,
        details: []const u8,
        timestamp: i64,
    };
}

pub const StateVectorLogEvent = struct {
    client: u64,
    clock: u64,
    timestamp: i64,
};

pub const GenericEvent = struct {
    event_type: EventType = .generic,
    msg: []const u8,
    timestamp: i64,
};

pub const LogEventType = enum {
    blocklog,
    ibolog,
    cilog,
    svlog,
    genericlog,
    integlog,
};

pub fn InternalEventType(comptime T: type) type {
    return union(LogEventType) {
        blocklog: BlockLogEventType(T),
        ibolog: IBOLogEventType(T),
        cilog: CILogEventType(T),
        svlog: StateVectorLogEvent,
        genericlog: GenericEvent,
        integlog: IntegrationLogEventType(T),
    };
}

pub const StructuredLogger = struct {
    file: std.fs.File,
    mutex: std.Thread.Mutex,
    allocator: std.mem.Allocator,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, filepath: []const u8) !Self {
        const file = try std.fs.cwd().createFile(filepath, .{});

        return Self{
            .file = file,
            .mutex = std.Thread.Mutex{},
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *Self) !void {
        // Write closing JSON array
        self.file.close();
    }

    pub fn log(self: *Self, event: anytype) !void {
        self.mutex.lock();
        defer self.mutex.unlock();

        const json = try std.json.stringifyAlloc(self.allocator, event, .{});
        defer self.allocator.free(json);

        try self.file.writeAll(json);
        try self.file.writeAll("\n");
    }
};

pub const Replay = struct {
    internal_events: *std.ArrayList(InternalEventType(ID)),

    const Self = @This();

    // try accepting an allocator and create the ArrayList in the init function
    // it wont work, FOW
    pub fn init(allocator: *std.ArrayList(InternalEventType(ID))) Self {
        return .{
            .internal_events = allocator,
        };
    }

    pub fn parse_log(self: *Self, allocator: std.mem.Allocator, path: []const u8) !void {
        const file = try std.fs.cwd().openFile(path, .{});
        var buf_reader = std.io.bufferedReader(file.reader());
        var in_stream = buf_reader.reader();

        // Reset file cursor to beginning
        try file.seekTo(0);

        while (true) {
            // Read a line, getting an owned slice
            const line = in_stream.readUntilDelimiterAlloc(allocator, '\n', 1024) catch |err| switch (err) {
                error.EndOfStream => break,
                else => return err,
            };
            defer allocator.free(line);

            const parsed = try readConfig(allocator, line);
            try self.internal_events.append(parsed.value);
            // std.debug.print("V: {any}", .{parsed.value});
        }
    }

    fn readConfig(allocator: std.mem.Allocator, data: []const u8) !std.json.Parsed(InternalEventType(ID)) {
        return std.json.parseFromSlice(InternalEventType(ID), allocator, data, .{ .allocate = .alloc_always, .ignore_unknown_fields = true });
    }
};

pub fn main() !void {
    var alloc = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer alloc.deinit();

    var ls = std.ArrayList(InternalEventType(ID)).init(alloc.allocator());
    var r = Replay.init(&ls);

    try r.parse_log(alloc.allocator(), "/home/amogh/projects/y-zig/test.log");
}

================
File: src/block_store.zig
================
const std = @import("std");
const SearchMarkerType = @import("./search_marker.zig").SearchMarkerType;
const Marker = @import("./search_marker.zig").Marker;
const MarkerError = @import("./search_marker.zig").MarkerError;
const Clock = @import("global_clock.zig").MonotonicClock;
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;

pub const ID = struct {
    clock: u64,
    client: u64,

    pub fn id(clock: u64, client: u64) ID {
        return ID{
            .clock = clock,
            .client = client,
        };
    }
};

// TODO: auto generate and persist this
const LOCAL_CLIENT = 1;

// Special Blocks indicating first and last elements
pub const SPECIAL_CLOCK_LEFT = 0;
pub const SPECIAL_CLOCK_RIGHT = 1;

// Block is a unit of an event totally ordered over a set such events
pub const Block = struct {
    id: ID,
    left_origin: ?ID,
    right_origin: ?ID,
    left: ?*Block,
    right: ?*Block,
    content: []const u8,
    isDeleted: bool = false,

    const Self = @This();

    pub fn block(id: ID, text: []const u8) Block {
        return Block{
            .id = id,
            .left = null,
            .left_origin = null,
            .right = null,
            .right_origin = null,
            .content = text,
        };
    }

    // attaches left and right to self
    fn attach_neighbor(self: *Self, left: *Block, right: *Block) void {
        left.right = self;
        self.left = left;
        self.right = right;
        right.left = self;
    }
};

// BlockStore is a primary way of doing ops on the sequenced list of blocks
pub fn BlockStoreType() type {
    const markers = SearchMarkerType();

    return struct {
        start: ?*Block = null,
        length: usize = 0,
        allocator: Allocator,
        marker_system: *markers,
        monotonic_clock: *Clock,
        state_vector: std.AutoHashMap(u64, u64),

        const Self = @This();

        pub fn init(allocator: Allocator, marker_system: *markers, clock: *Clock) Self {
            var state_vector = std.AutoHashMap(u64, u64).init(allocator);
            state_vector.put(LOCAL_CLIENT, 1) catch unreachable;

            return Self{
                .allocator = allocator,
                .marker_system = marker_system,
                .monotonic_clock = clock,
                .state_vector = state_vector,
            };
        }

        pub fn deinit(self: *Self) void {
            var next = self.start;
            while (next != null) {
                self.allocator.destroy(self.start.?);
                next = next.?.right;
            }
        }

        // when items being added at end from remote update, this will never match for the right origin
        // because we are checking clock and client for right sentinel which will not match
        pub fn get_block_by_id(self: Self, id: ID) ?*Block {
            var next = self.start;
            while (next != null) {
                if (next.?.id.clock == id.clock and next.?.id.client == id.client) return next;
                next = next.?.right;
            }
            return next;
        }

        pub fn get_block_index_by_id(self: *Self, id: ID) !?usize {
            return try self.marker_system.get_block_pos(id);
        }

        pub fn getState(self: *Self, client: u64) u64 {
            return self.state_vector.get(client) orelse 0;
        }

        // TODO: ponder: if someone gives a clock of 10 and highest value watched is 5
        // that would case this sv to misrepresent dot cloud space.
        pub fn updateState(self: *Self, block: *Block) !void {
            const current = self.getState(block.id.client);
            if (block.id.clock > current) {
                try self.state_vector.put(block.id.client, block.id.clock);
            }
        }

        // will allocate some space in memory and return the pointer to it.
        pub fn allocate_block(self: *Self, block: Block) !*Block {
            const new_block = try self.allocator.create(Block);
            new_block.* = block;
            return new_block;
        }

        // Returns the client ID if we're missing updates, null if we have everything
        pub fn getMissing(self: *Self, block: *Block) !?u64 {
            // Skip checking origin reference if it's a sentinel
            if (block.left_origin) |origin| {
                // If origin is from another client and we have a gap between the referenced origins clock vs
                // what we have locally for the same client. this is indicating that we are getting a remote
                // block whose left origin has a much higher clock for a client than what we see locally
                // for the same client
                if (origin.client != block.id.client and
                    // TODO: yjs uses >= for some reason, i have not figured out yet so i will go with > only since it makes
                    // sense to me
                    origin.clock > self.getState(origin.client))
                {
                    return origin.client;
                }
            }

            // same logic as above but for right origin
            if (block.right_origin) |r_origin| {
                // If right origin is from another client and we don't have its clock yet
                if (r_origin.client != block.id.client and
                    r_origin.clock > self.getState(r_origin.client))
                {
                    return r_origin.client;
                }
            }

            // We have all dependencies, try to find actual blocks, if not found, simply return the client id
            //
            // no gaps, safe to assign the left origin as the left neighbor
            if (block.left_origin) |origin| {
                // assign left neighbor, if we dont find the left origin block in our blockstore
                // return the origins client as missing client
                block.left = self.get_block_by_id(origin);
            }

            // no gaps, safe to assign the right origin as the right neighbor
            if (block.right_origin) |r_origin| {
                // assign right neighbor, if we dont find the right origin block in our blockstore
                // return the origins client as missing client
                block.right = self.get_block_by_id(r_origin);
            }

            return null;
        }

        // this function should only be called in certain scenarios when a block actually requires
        // splitting, the caller needs to have all checks in place before calling this function
        // we dont want to split weirdly
        fn split_and_add_block(self: *Self, m: Marker, new_block: *Block, split_point: usize) !void {
            // use split point to create two blocks
            const blk_left = try self.allocate_block(
                Block.block(
                    ID.id(self.montonic_clock.getClock(), LOCAL_CLIENT),
                    try self.allocator.dupe(u8, m.item.content[0..split_point]),
                ),
            );

            const blk_right = try self.allocate_block(
                Block.block(
                    ID.id(self.monotonic_clock.getClock(), LOCAL_CLIENT),
                    try self.allocator.dupe(u8, m.item.content[split_point..]),
                ),
            );
            // insert left split block at index
            // insert new_block at the right of left split
            // insert right split block at the right of new_block
            self.replace_repair(m.item, blk_left, blk_right);
            // attaches the new left and right blocks to the new_block
            // we just created
            new_block.attach_neighbor(blk_left, blk_right);
        }

        // replaces `old` block by provided new_left and new_right
        // and de-allocates `old`
        fn replace_repair(self: *Self, old: *Block, new_left: *Block, new_right: *Block) void {
            if (old.left != null) {
                old.left.?.right = new_left;
                new_left.left = old.left;
            } else {
                self.start = new_left;
            }

            if (old.right != null) {
                new_right.right = old.right;
                old.right.?.left = new_right;
            }
        }

        // attaches new_block and neighbor block 'm' as each other's neighbor
        fn attach_neighbor(new_block: *Block, m: *Block) void {
            assert(m.left != null);
            // attach neighbors
            new_block.left = m.left;
            new_block.left_origin = m.left.?.id;

            new_block.right = m;
            new_block.right_origin = m.id;

            new_block.left.?.right = new_block;
            m.left = new_block;
        }

        // attaches new_block to the end of the block store
        // which is the `m` marker we get from the marker_system
        fn attach_last(new_block: *Block, m: *Block) void {
            m.right = new_block;
            new_block.right_origin = ID.id(SPECIAL_CLOCK_RIGHT, 1);
            new_block.left = m;
            new_block.left_origin = m.id;
        }

        // attaches new_block to the beginning of the block store
        fn attach_first(self: *Self, new_block: *Block) void {
            new_block.left_origin = ID.id(SPECIAL_CLOCK_LEFT, 1);
            new_block.right_origin = ID.id(SPECIAL_CLOCK_RIGHT, 1);
            self.start = new_block;
        }

        // TODO: figure out how to not run out of markers in this flow
        pub fn delete_text(self: *Self, index: usize, length: usize) !void {
            var deleted_length: usize = 0;
            while (deleted_length < length) {
                const m = try self.marker_system.find_block(index);
                if (m.item.content.len > length) {
                    try self.split_and_delete_block(m.item, length - deleted_length);
                    deleted_length += m.item.content.len;
                } else {
                    try self.delete_block(m.item);
                    self.marker_system.deleteMarkerAtPos(m.pos);
                    deleted_length += m.item.content.len;
                }
                try self.marker_system.update_markers(index, deleted_length, .del);
            }
        }

        fn delete_block(self: *Self, block: *Block) !void {
            // new deleted block where text is empty and isDeleted is true
            const new_deleted_block = try self.allocator.create(Block);
            new_deleted_block.* = Block{
                .content = "",
                .id = ID{ .client = LOCAL_CLIENT, .clock = 0 },
                .isDeleted = true,
                .left_origin = block.left_origin,
                .right_origin = block.right_origin,
                .left = null,
                .right = null,
            };

            // repair neighbor connections
            if (block.left != null) {
                block.left.?.right = new_deleted_block;
                new_deleted_block.left = block.left;
            }
            if (block.right != null) {
                block.right.?.left = new_deleted_block;
                new_deleted_block.right = block.right;
            }

            // de-allocate block
            self.allocator.destroy(block);
        }

        // replaces block with another block where isDeleted is true
        // de-allocates block
        fn split_and_delete_block(self: *Self, block: *Block, remaining_length: usize) !void {
            // new deleted block where text is empty and isDeleted is true
            const new_deleted_block = try self.allocator.create(Block);
            new_deleted_block.* = Block{
                .content = "",
                .id = ID{ .client = LOCAL_CLIENT, .clock = 0 },
                .isDeleted = true,
                .left_origin = block.left_origin,
                .right_origin = block.right_origin,
                .left = null,
                .right = null,
            };

            const blk_right = try self.allocate_block(
                Block.block(
                    ID.id(self.monotonic_clock.getClock(), LOCAL_CLIENT),
                    try self.allocator.dupe(u8, block.content[remaining_length..]),
                ),
            );

            // repair neighbor connections
            if (block.left != null) block.left.?.right = new_deleted_block;
            new_deleted_block.right = blk_right;
            blk_right.left = new_deleted_block;
            if (block.right != null) {
                block.right.?.left = blk_right;
                blk_right.right = block.right;
            }

            // de-allocate block
            self.allocator.destroy(block);
        }

        pub fn insert_text(self: *Self, index: usize, text: []const u8) !void {
            const new_block = try self.allocator.create(Block);
            new_block.* = Block.block(ID.id(self.monotonic_clock.getClock(), LOCAL_CLIENT), text);

            try self.insert(index, new_block);

            self.length += text.len;
            try self.updateState(new_block);
        }

        // inserts a text content in the block store
        // TODO: support the case where a new item is added at 0th index when one already exists
        pub fn insert(self: *Self, index: usize, new_block: *Block) !void {
            const m = self.marker_system.find_block(index) catch |err| switch (err) {
                MarkerError.NoMarkers => try self.marker_system.new(index, new_block),
                else => unreachable,
            };

            if (self.start == null) {
                self.attach_first(new_block);
                return;
            }

            if (index >= self.length) {
                attach_last(new_block, m.item);
                return;
            }

            if (index > m.pos and index < m.item.content.len) {
                const split_point = m.item.content.len - index - 1;
                try self.split_and_add_block(m, new_block, split_point);
                self.marker_system.deleteMarkerAtPos(m.pos);
                try self.marker_system.update_markers(index, new_block.content.len, .add);
                _ = try self.marker_system.new(index, new_block);
            } else {
                attach_neighbor(new_block, m.item);
                try self.marker_system.update_markers(index, new_block.content.len, .add);
            }
        }

        pub fn content(self: *Self, allocator: *std.ArrayList(u8)) !void {
            var next = self.start;
            while (next != null) {
                try allocator.appendSlice(next.?.content);
                next = next.?.right orelse break;
            }
        }

        fn compareIDs(this: ?ID, that: ?ID) bool {
            if (this == null or that == null) return false;
            if (this.?.clock == that.?.clock and this.?.client == that.?.client) return true;
            return false;
        }

        // caller should take care of adding the block to the respective dot cloud
        pub fn integrate(self: *Self, block: *Block) !void {
            assert(block.left_origin != null and block.right_origin != null);

            var isConflict = false;
            // this case check can be a false positive, if your blocks do no go through neighbor checking
            // before integrating this can act as a conflict (since remote blocks always come with empty left/right neighbors)
            // caller's responsibility to check if neighbor asg is possible or not based on the origins
            // if not only then call the integration process.
            if (block.left == null and block.right == null) {
                isConflict = true;
            } else if (block.left == null and block.right != null) {
                const r = block.right.?;
                if (r.left != null) {
                    isConflict = true;
                }
            } else if (block.left != null) {
                if (block.left.?.right != block.right) {
                    isConflict = true;
                }
            } else unreachable;

            if (isConflict) {
                // set the left pointer, this is used across the conflict resolution loop to figure out the new neighbors
                // for ' block'
                var left = block.left;
                var o: ?*Block = null;
                // if we have a left neighbor, set the right of it as the first conflicting item
                // since we cannot conflict with our own left.
                if (left != null) {
                    o = left.?.right;
                } else {
                    // if the left neighbor of the new block is null, we can start
                    // at the start of the document
                    o = self.start orelse unreachable;
                }

                // now the first conflicting item has been set
                // let's move on to the conflict resolution loop

                // this array acts as a distinct set of items that are "potential" conflicts with the `block`
                // this is because we have not found the right neighbor for our block yet
                // at every point where we know that these set of items for sure won't conflict with the `block`
                // we clear this set out
                var conflicting_items = std.AutoHashMap(ID, void).init(self.allocator);
                defer conflicting_items.deinit();

                // this array acts as a distinct set of items which we consider as falling before `block`
                // this set is used in conjunction with the conflicting items set to figure out WHEN to clear
                // the conflicting set! this is used to avoid origin crossing since we only increment our left
                // pointer when we find that left origin is not the same for `block` and `o` but the left origin
                // of `o` falls in this set but is not present in the conflicting items set, this is because we know
                // for sure such items will not conflict with the `block`
                var items_before_origin = std.AutoHashMap(ID, void).init(self.allocator);
                defer items_before_origin.deinit();

                // conflict resolution loop starts
                while (o != null and o != block.right) {
                    try items_before_origin.put(o.?.id, {});
                    try conflicting_items.put(o.?.id, {});

                    // check for same left derivation points
                    if (o != null and BlockStoreType().compareIDs(o.?.left_origin, block.left_origin)) {
                        // if left origin is same, order by client ids - we go with the ascending order of client ids from left ro right
                        if (o.?.id.client < block.id.client) {
                            left = o.?;
                            conflicting_items.clearAndFree();
                        } else if (o != null and BlockStoreType().compareIDs(o.?.right_origin, block.right_origin)) {
                            // this loop breaks because we know that `block` and `o` had the same left,right derivation points.
                            break;
                        }
                        // check if the left origin of the conflicting item is in the ibo set but not in the conflicting items set
                        // if that is the case, we can clear the conflicting items set and increment our left pointer to point to the
                        // `o` block
                    } else if (o.?.left_origin != null) {
                        const blk = self.get_block_by_id(o.?.left_origin.?);

                        if (blk != null and items_before_origin.contains(blk.?.id) and !conflicting_items.contains(blk.?.id)) {
                            left = o.?;
                            conflicting_items.clearAndFree();
                        } else {}
                    } else {
                        // we might have found our left
                        break;
                    }

                    o = o.?.right;
                }
                // set the new neighbor
                block.left = left;
            }

            // reconnect left neighbor
            if (block.left != null) {
                block.right = block.left.?.right;
                block.left.?.right = block;
            } else {
                block.right = self.start;
                self.start.?.left = block;
                self.start = block;
            }

            // reconnect right neighbor
            if (block.right != null) {
                block.right.?.left = block;
            }
        }
    };
}

const t = std.testing;
const mem = std.mem;

test "localInsert" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");

    try array.insert_text(1, "B");

    try array.insert_text(2, "C");

    try array.insert_text(3, "D");

    try array.insert_text(4, "E");
    try array.insert_text(5, "F");

    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();

    try t.expectEqualSlices(u8, "ABCDEF", content);
}

test "localDelete" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");
    try array.insert_text(1, "B");
    try array.delete_text(1, 1);

    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();

    try t.expectEqualSlices(u8, "A", content);
}

test "localDelete - run" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");
    try array.insert_text(1, "B");
    try array.insert_text(2, "CDEF");
    try array.delete_text(1, 3);

    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();

    try t.expectEqualSlices(u8, "AEF", content);
}

test "localInsert between" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");

    try array.insert_text(1, "B");

    try array.insert_text(1, "C");

    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();

    try t.expectEqualSlices(u8, "ACB", content);
}

test "searchMarkers" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();

    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");

    try array.insert_text(1, "B");

    try array.insert_text(2, "C");

    try array.insert_text(3, "D");

    try array.insert_text(4, "E");

    var marker = try marker_system.find_block(0);
    try t.expectEqualStrings("A", marker.item.content);

    marker = try marker_system.find_block(3);
    try t.expectEqualStrings("D", marker.item.content);

    marker = try marker_system.find_block(59);
    try t.expectEqualStrings("E", marker.item.content);
}

test "integrate - basic non-conflicting case" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Setup marker system
    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    // Create initial blocks: "A" -> "B"
    try array.insert_text(0, "A");
    try array.insert_text(1, "B");

    // Create a new block "C" to insert between A and B
    const block_c = try allocator.create(Block);
    block_c.* = Block.block(ID.id(3, 2), "C");

    // Get references to A and B blocks
    const block_a = array.start.?;
    const block_b = block_a.right.?;

    // Set up proper block relationships
    block_c.left = block_a;
    block_c.right = block_b;
    block_c.left_origin = block_a.id; // A's actual ID
    block_c.right_origin = block_b.id; // B's actual ID

    // Integrate block C
    try array.integrate(block_c);

    // Verify the final sequence is "A" -> "C" -> "B"
    var buf = std.ArrayList(u8).init(allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "ACB", content);
}

test "integrate - concurrent edits at same position" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Setup marker system
    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    // Create initial blocks: "A" -> "B"
    try array.insert_text(0, "A");
    try array.insert_text(1, "B");

    // Get references to A and B blocks
    const block_a = array.start.?;
    const block_b = block_a.right.?;

    // Create two concurrent blocks "C" and "D" from different clients
    // Both trying to insert between A and B
    const block_c = try allocator.create(Block);
    block_c.* = Block.block(ID.id(2, 1), "C"); // Client 1

    const block_d = try allocator.create(Block);
    block_d.* = Block.block(ID.id(2, 2), "D"); // Client 2

    // Set up relationships for both blocks
    block_c.left = block_a;
    block_c.right = block_b;
    block_c.left_origin = block_a.id;
    block_c.right_origin = block_b.id;

    block_d.left = block_a;
    block_d.right = block_b;
    block_d.left_origin = block_a.id;
    block_d.right_origin = block_b.id;

    // Integrate both blocks
    try array.integrate(block_c);
    try array.integrate(block_d);

    // Verify final sequence - since client 1 < client 2,
    // we expect "C" to be before "D"
    var buf = std.ArrayList(u8).init(allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "ACDB", content);
}

test "integrate - same client different clocks" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Setup marker system
    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    // Create initial blocks: "A" -> "B"
    try array.insert_text(0, "A");
    try array.insert_text(1, "B");

    const block_a = array.start.?;
    const block_b = block_a.right.?;

    const block_c1 = try allocator.create(Block);
    block_c1.* = Block.block(ID.id(3, 1), "C1");
    block_c1.left = block_a;
    block_c1.right = block_b;
    block_c1.left_origin = block_a.id;
    block_c1.right_origin = block_b.id;

    const block_c2 = try allocator.create(Block);
    block_c2.* = Block.block(ID.id(4, 1), "C2"); // Same client (1), different clock (4)
    block_c2.left = block_a;
    block_c2.right = block_b;
    block_c2.left_origin = block_a.id;
    block_c2.right_origin = block_b.id;

    try array.integrate(block_c1);
    try array.integrate(block_c2);

    var buf = std.ArrayList(u8).init(allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "AC2C1B", content);
}

test "integrate - duplicate ID" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");
    try array.insert_text(1, "B");

    const block_a = array.start.?;
    const block_b = block_a.right.?;

    const block_c = try allocator.create(Block);
    block_c.* = Block.block(ID.id(3, 1), "C");
    block_c.left = block_a;
    block_c.right = block_b;
    block_c.left_origin = block_a.id;
    block_c.right_origin = block_b.id;

    const block_duplicate = try allocator.create(Block);
    block_duplicate.* = Block.block(ID.id(3, 1), "D"); // Same ID as block_c
    block_duplicate.left = block_a;
    block_duplicate.right = block_b;
    block_duplicate.left_origin = block_a.id;
    block_duplicate.right_origin = block_b.id;

    try array.integrate(block_c);
    try array.integrate(block_duplicate);

    var buf = std.ArrayList(u8).init(allocator);
    try array.content(&buf);
    const content = try buf.toOwnedSlice();
    // Duplicate is treated as a concurrent edit at the same time but in this case
    // it's the same client, so it acts as a local insert
    try t.expectEqualSlices(u8, "ADCB", content);
}

test "integrate - null origins should fail" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var array = BlockStoreType().init(allocator, &marker_system, &clk);
    defer array.deinit();

    try array.insert_text(0, "A");
    try array.insert_text(1, "B");

    const block_a = array.start.?;
    const block_b = block_a.right.?;

    const block_null = try allocator.create(Block);
    block_null.* = Block.block(ID.id(5, 1), "C");
    block_null.left = block_a;
    block_null.right = block_b;
    block_null.left_origin = null;
    block_null.right_origin = null;

    // This should trigger an assertion failure in debug mode
    if (!std.debug.runtime_safety) {
        try array.integrate(block_null);
    }
}

test "same origin multiple items - basic ordering" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);
    defer store.deinit();

    // Create initial block
    try store.insert_text(0, "A");
    const origin_block = store.start.?;

    // Create blocks with same origin but different timestamps
    try store.insert_text(1, "B");
    try store.insert_text(1, "C");

    // Get the actual blocks in order they appear in the list
    const first_insert = origin_block.right.?; // Points to C
    const second_insert = first_insert.right.?; // Points to B

    // Verify correct ordering by clock
    // The later insertion (C) should have a higher clock than earlier insertion (B)
    try t.expect(first_insert.id.clock > second_insert.id.clock);

    // Also verify the actual content to make our test more explicit
    try t.expectEqualStrings("C", first_insert.content);
    try t.expectEqualStrings("B", second_insert.content);
}

test "origin crossing prevention - basic" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);
    defer store.deinit();

    // Create initial structure: "ABC"
    try store.insert_text(0, "A");
    try store.insert_text(1, "B");
    try store.insert_text(2, "C");

    const a_block = store.start.?;
    const b_block = a_block.right.?;
    const c_block = b_block.right.?;

    // Try to create blocks that would cause origin crossing
    const block_x = try allocator.create(Block);
    block_x.* = Block.block(ID.id(2, 0), "X");
    block_x.left_origin = c_block.id;
    block_x.right_origin = a_block.id;

    // This integration should prevent origin crossing
    try store.integrate(block_x);

    // Verify final order maintains no crossing
    var current = store.start;
    var content = std.ArrayList(u8).init(allocator);
    while (current != null) : (current = current.?.right) {
        try content.appendSlice(current.?.content);
    }

    const result = content.items;
    // X should not be between A and C (which would indicate crossing)
    try t.expect(!containsSubsequence(result, "AXC"));
}

fn containsSubsequence(haystack: []const u8, needle: []const u8) bool {
    if (needle.len > haystack.len) return false;
    for (0..(haystack.len - needle.len + 1)) |i| {
        if (mem.eql(u8, haystack[i..(i + needle.len)], needle)) {
            return true;
        }
    }
    return false;
}

test "blockSplit - basic" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(t.allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);
    defer store.deinit();

    try store.insert_text(0, "ABC");
    try store.insert_text(1, "DEF");

    var current = store.start;
    var content = std.ArrayList(u8).init(allocator);
    while (current != null) : (current = current.?.right) {
        try content.appendSlice(current.?.content);
    }

    const result = content.items;
    try t.expectEqualStrings("ADEFBC", result);
}

test "blockSplit - twice the split" {
    var clk = Clock.init();

    var arena = std.heap.ArenaAllocator.init(t.allocator);

    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);

    var store = BlockStoreType().init(allocator, &marker_system, &clk);
    defer store.deinit();

    try store.insert_text(0, "ABC");
    try store.insert_text(1, "DEF");
    try store.insert_text(1, "XY");

    var current1 = store.start;
    var content1 = std.ArrayList(u8).init(allocator);
    while (current1 != null) : (current1 = current1.?.right) {
        try content1.appendSlice(current1.?.content);
    }
    const result = content1.items;

    try t.expectEqualStrings("AXYDEFBC", result);
}

test "blockSplit - thrice the split" {
    var clk = Clock.init();

    var arena = std.heap.ArenaAllocator.init(t.allocator);

    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);

    var store = BlockStoreType().init(allocator, &marker_system, &clk);
    defer store.deinit();

    try store.insert_text(0, "ABC");
    try store.insert_text(1, "DEF");
    try store.insert_text(1, "LMN");
    try store.insert_text(1, "PQR");

    var current1 = store.start;
    var content1 = std.ArrayList(u8).init(allocator);
    while (current1 != null) : (current1 = current1.?.right) {
        try content1.appendSlice(current1.?.content);
    }
    const result = content1.items;

    try t.expectEqualStrings("APQRLMNDEFBC", result);
}

================
File: src/doc.zig
================


================
File: src/global_clock.zig
================
pub const MonotonicClock = struct {
    clock: u64,
    const Self = @This();

    pub fn init() Self {
        return Self{
            .clock = 2,
        };
    }
    pub fn getClock(self: *MonotonicClock) u64 {
        self.clock += 1;
        return self.clock;
    }
};

================
File: src/main.zig
================
const std = @import("std");

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
}

================
File: src/search_marker.zig
================
const std = @import("std");
const Block = @import("./block_store.zig").Block;
const ID = @import("./block_store.zig").ID;

pub const Marker = struct {
    item: *Block,
    pos: usize,
    timestamp: i128,
};

pub const MarkerError = error{
    NoMarkers,
    BlockNotFound,
};

// SearchMarkers are indexes for the underlying block store.
// they help save time traversing a block store
pub fn SearchMarkerType() type {
    return struct {
        markers: *std.AutoHashMap(usize, Marker),
        curr_idx: u8,
        max_cap: u8 = 10,

        const Self = @This();

        pub fn init(allocator: *std.AutoHashMap(usize, Marker)) Self {
            return Self{
                .markers = allocator,
                .curr_idx = 0,
            };
        }

        pub fn new(self: *Self, pos: usize, block: *Block) !Marker {
            const m = Marker{
                .pos = pos,
                .item = block,
                .timestamp = std.time.milliTimestamp(),
            };
            try self.markers.put(@intFromPtr(block), m);
            self.curr_idx += 1;
            return m;
        }

        pub const OpType = enum {
            add,
            del,
        };

        // should be called when a new block is added or an existing block is deleted
        // updates positions for block pointers
        pub fn update_markers(self: *Self, pos: usize, length: usize, opType: OpType) !void {
            var iter = self.markers.iterator();
            var next = iter.next();
            while (next != null) : (next = iter.next()) {
                var value = next.?.value_ptr;
                switch (opType) {
                    .add => if (value.pos >= pos) {
                        value.pos += length;
                        value.timestamp = std.time.timestamp();
                    },
                    .del => if (value.pos >= pos) {
                        value.pos -= length;
                        value.timestamp = std.time.timestamp();
                    },
                }
            }
            return;
        }

        pub fn deleteMarkerAtPos(self: *Self, pos: usize) void {
            var iter = self.markers.iterator();
            var next = iter.next();
            while (next != null) : (next = iter.next()) {
                if (pos == next.?.value_ptr.*.pos) {
                    _ = self.markers.remove(next.?.key_ptr.*);
                }
            }
        }

        pub fn destroy_markers(self: *Self) void {
            self.markers.clearAndFree();
            self.curr_idx = 0;
        }

        pub fn get_block_pos(self: *Self, id: ID) !usize {
            if (self.markers.count() == 0) return MarkerError.NoMarkers;

            var iter = self.markers.iterator();
            var next = iter.next();

            while (next != null) : (next = iter.next()) {
                if (next.?.value_ptr.item.id == id) {
                    return next.?.value_ptr.pos;
                }
            }

            return MarkerError.BlockNotFound;
        }

        // find_marker returns the best possible marker for a given position in the document
        pub fn find_block(self: *Self, pos: usize) !Marker {
            if (self.markers.count() == 0) return MarkerError.NoMarkers;

            var iter = self.markers.iterator();
            var next = iter.next();

            const marker = next.?.value_ptr;

            while (next != null) : (next = iter.next()) {
                if (pos == next.?.value_ptr.pos) {
                    return next.?.value_ptr.*;
                }
            }

            var b: ?*Block = marker.item;
            // this will always point at the start of some block
            // because we traverse block by block and increment this
            // offset by the traversed block's content length
            var p = marker.pos;

            // TODO: prob - still working when p is incremented on the wrong block
            while (b != null and p < pos) {
                if (b.?.isDeleted == true) {
                    b = b.?.right orelse break;
                    continue;
                }
                b = b.?.right orelse break;
                p += b.?.content.len;
            }

            while (b != null and p > pos) {
                if (b.?.isDeleted == true) {
                    b = b.?.left orelse break;
                    continue;
                }
                b = b.?.left orelse break;
                p -= b.?.content.len;
            }

            // TODO: from yjs - making sure the left can't be merged with
            // TODO: update existing marker upon reaching limit
            const final = Marker{ .pos = p, .item = b.?, .timestamp = std.time.milliTimestamp() };
            try self.markers.put(@intFromPtr(b.?), final);
            return final;
        }
    };
}

================
File: src/test.zig
================


================
File: src/update.zig
================
const std = @import("std");

const Block = @import("block_store.zig").Block;
const BlockStoreType = @import("block_store.zig").BlockStoreType;
const ID = @import("block_store.zig").ID;

const SearchMarkerType = @import("search_marker.zig").SearchMarkerType;
const Marker = @import("./search_marker.zig").Marker;
const MarkerError = @import("./search_marker.zig").MarkerError;

const SENTINEL_LEFT = @import("block_store.zig").SPECIAL_CLOCK_LEFT;
const SENTINEL_RIGHT = @import("block_store.zig").SPECIAL_CLOCK_RIGHT;

const Clock = @import("global_clock.zig").MonotonicClock;

pub const Blocks = *std.ArrayList(Block);

pub const PendingStruct = struct {
    blocks: std.AutoHashMap(ID, *Block),
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) PendingStruct {
        return .{
            .blocks = std.AutoHashMap(ID, *Block).init(allocator),
            .allocator = allocator,
        };
    }

    pub fn addPending(self: *PendingStruct, block: *Block) !void {
        try self.blocks.put(block.id, block);
    }
};

pub const DeleteItem = struct {
    // Starting clock value
    clock: u64,
    // Number of items deleted in sequence
    len: u64,

    // Constructor for convenience
    pub fn item(clock: u64, len: u64) DeleteItem {
        return DeleteItem{
            .clock = clock,
            .len = len,
        };
    }
};

pub const DeleteSet = struct {
    // Maps client IDs to arrays of DeleteItems
    clients: std.AutoHashMap(u64, std.ArrayList(DeleteItem)),
    allocator: std.mem.Allocator,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator) DeleteSet {
        return DeleteSet{
            .clients = std.AutoHashMap(u64, std.ArrayList(DeleteItem)).init(allocator),
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *DeleteSet) void {
        var it = self.clients.iterator();
        while (it.next()) |entry| {
            entry.value_ptr.deinit();
        }
        self.clients.deinit();
    }

    pub fn addToDeleteSet(self: *Self, client: u64, clock: u64, length: u64) !void {
        // If length is 0, there's nothing to delete
        if (length == 0) return;

        var entry = try self.clients.getOrPut(client);
        if (!entry.found_existing) {
            // Create a new array list for this client
            entry.value_ptr.* = std.ArrayList(DeleteItem).init(self.allocator);
        }

        // Add the delete item
        try entry.value_ptr.append(DeleteItem.item(clock, length));
    }

    pub fn isDeleted(self: *Self, id: ID) bool {
        const deleteItems = self.clients.get(id.client) orelse return false;

        for (deleteItems.items) |di| {
            if (di.clock == id.clock) {
                return true;
            }
        }

        return false;
    }
};

// Updates is an incoming message from a remote peer
pub const Updates = struct {
    updates: *std.HashMap(u64, Blocks, std.hash_map.AutoContext(u64), 90),
    deletes: DeleteSet,
};

pub const UpdateStore = struct {
    allocator: std.mem.Allocator,
    pending: PendingStruct,
    pendingDs: DeleteSet,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator) Self {
        const ps = PendingStruct.init(allocator);
        const pds = DeleteSet.init(allocator);
        return .{
            .allocator = allocator,
            .pending = ps,
            .pendingDs = pds,
        };
    }

    pub fn apply_update(self: *Self, store: *BlockStoreType(), update: Updates) !void {
        // integrate updates
        var iter = update.updates.iterator();
        while (iter.next()) |entry| {
            const blocks = entry.value_ptr.*;

            for (blocks.items) |block| {
                // Allocate space for this block
                const blk = try store.allocate_block(block);

                // Check if we have all dependencies
                if (try store.getMissing(blk) != null) {
                    // We're missing updates from this client, add to pending queue
                    try self.pending.addPending(blk);
                    continue;
                }

                // Try to integrate
                store.integrate(blk) catch {
                    try self.pending.addPending(blk);
                    continue;
                };

                // Update state after successful integration
                try store.updateState(blk);
            }
        }
        // integrate deletes
        var delete_iter = update.deletes.clients.iterator();
        while (delete_iter.next()) |entry| {
            const deleted_items = entry.value_ptr.*;
            const client = entry.key_ptr.*;

            for (deleted_items.items) |remote_item| {
                const local_item = store.get_block_by_id(ID.id(remote_item.clock, client));
                if (local_item == null) continue;

                if (remote_item.clock > local_item.?.id.clock) {
                    try store.delete_text(try store.get_block_index_by_id(local_item.?.id), remote_item.len);
                }
            }
        }
        return;
    }
};

const t = std.testing;

fn createTestBlock(allocator: std.mem.Allocator, id: ID, content: []const u8) !*Block {
    const block = try allocator.create(Block);
    block.* = Block.block(id, content);
    return block;
}

test "apply_update: concurrent client updates:in the middle: happy-flow" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);

    // Insert first block 'A'
    try store.insert_text(0, "A");
    try store.insert_text(1, "B");

    // Get the actual block A (not sentinel)
    const base_block = store.start.?;
    try t.expect(std.mem.eql(u8, base_block.content, "A"));

    const base_blockR = store.start.?.right.?;
    try t.expect(std.mem.eql(u8, base_blockR.content, "B"));

    // Create concurrent blocks
    var blocks_list = std.ArrayList(Block).init(allocator);
    defer blocks_list.deinit();

    // Create block B
    const block_b = try createTestBlock(allocator, ID.id(2, 2), "C");
    block_b.* = Block{
        .id = block_b.id,
        .content = "C",
        .left_origin = base_block.id,
        .right_origin = base_blockR.id,
        .left = null,
        .right = null,
    };
    try blocks_list.append(block_b.*);

    // Create block C
    const block_c = try createTestBlock(allocator, ID.id(2, 4), "D");
    block_c.* = Block{
        .id = block_c.id,
        .content = "D",
        .left_origin = base_block.id,
        .right_origin = base_blockR.id,
        .left = null,
        .right = null,
    };
    try blocks_list.append(block_c.*);

    // Setup updates
    var updates = std.HashMap(u64, Blocks, std.hash_map.AutoContext(u64), 90).init(allocator);
    defer updates.deinit();
    try updates.put(1, &blocks_list);

    const up = Updates{
        .updates = &updates,
    };

    var us = UpdateStore.init(allocator);
    try us.apply_update(&store, up);

    // Verify content
    var buf = std.ArrayList(u8).init(allocator);
    try store.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "ACDB", content);
    try t.expect(us.pending.blocks.count() == 0);
}

test "apply_update: concurrent client updates:at the end: happy-flow" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Setup marker system
    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);

    // Create initial document: "AB"
    try store.insert_text(0, "A");
    try store.insert_text(1, "B");

    // Get base blocks
    const block_a = store.start.?;
    const block_b = block_a.right.?;

    // Create concurrent blocks to append at the end
    var blocks_list = std.ArrayList(Block).init(allocator);
    defer blocks_list.deinit();

    // Create block C: should append after B
    const block_c = try createTestBlock(allocator, ID.id(2, 2), "C");
    block_c.* = Block{
        .id = block_c.id,
        .content = "C",
        .left_origin = block_b.id,
        .right_origin = ID.id(SENTINEL_RIGHT, 2), // Points to end sentinel
        .left = null,
        .right = null,
    };
    try blocks_list.append(block_c.*);

    // Create block D: also appends after B
    const block_d = try createTestBlock(allocator, ID.id(2, 4), "D");
    block_d.* = Block{
        .id = block_d.id,
        .content = "D",
        .left_origin = block_b.id,
        .right_origin = ID.id(SENTINEL_RIGHT, 4),
        .left = null,
        .right = null,
    };
    try blocks_list.append(block_d.*);

    // Setup updates
    var updates = std.HashMap(u64, Blocks, std.hash_map.AutoContext(u64), 90).init(allocator);
    defer updates.deinit();
    try updates.put(1, &blocks_list);

    const up = Updates{
        .updates = &updates,
    };

    var us = UpdateStore.init(allocator);

    try us.apply_update(&store, up);
    // Verify content - should be ABCD since C has lower client clock than D
    var buf = std.ArrayList(u8).init(allocator);
    try store.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "ABCD", content);
    try t.expect(us.pending.blocks.count() == 0);
}

test "apply_update: concurrent client updates:at the start: happy-flow" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Setup marker system
    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);

    // Create initial document: "AB"
    try store.insert_text(0, "A");
    try store.insert_text(1, "B");

    // Get base blocks
    const block_a = store.start.?;

    // Create concurrent blocks to insert at start
    var blocks_list = std.ArrayList(Block).init(allocator);
    defer blocks_list.deinit();

    // Create block C: insert at start
    const block_c = try createTestBlock(allocator, ID.id(4, 2), "C");
    block_c.* = Block{
        .id = block_c.id,
        .content = "C",
        .left_origin = ID.id(SENTINEL_LEFT, 2), // Points to start sentinel
        .right_origin = block_a.id,
        .left = null,
        .right = null,
    };
    try blocks_list.append(block_c.*);

    var blocks_list_another = std.ArrayList(Block).init(allocator);
    defer blocks_list_another.deinit();

    // Create block D: also insert at start
    const block_d = try createTestBlock(allocator, ID.id(4, 4), "D");
    block_d.* = Block{
        .id = block_d.id,
        .content = "D",
        .left_origin = ID.id(SENTINEL_LEFT, 4),
        .right_origin = block_a.id,
        .left = null,
        .right = null,
    };
    try blocks_list_another.append(block_d.*);

    // Setup updates
    var updates = std.HashMap(u64, Blocks, std.hash_map.AutoContext(u64), 90).init(allocator);
    defer updates.deinit();
    try updates.put(2, &blocks_list);
    try updates.put(4, &blocks_list_another);

    const up = Updates{
        .updates = &updates,
    };

    var us = UpdateStore.init(allocator);

    try us.apply_update(&store, up);
    // Verify content - should be CDAB since C has lower client clock than D
    var buf = std.ArrayList(u8).init(allocator);
    try store.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "CDAB", content);
    try t.expect(us.pending.blocks.count() == 0);
}

test "apply_update: concurrent client updates:missing blocks" {
    var clk = Clock.init();
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Setup marker system
    var marker_list = std.AutoHashMap(usize, Marker).init(allocator);
    var marker_system = SearchMarkerType().init(&marker_list);
    var store = BlockStoreType().init(allocator, &marker_system, &clk);

    // Create initial document: "A"
    try store.insert_text(0, "A");

    // Get base block
    const block_a = store.start.?;

    // Create blocks with missing dependencies
    var blocks_list = std.ArrayList(Block).init(allocator);
    defer blocks_list.deinit();

    // Create block C that depends on missing block B
    const missing_block_id = ID.id(4, 2); // Block B that doesn't exist yet
    const block_c = try createTestBlock(allocator, ID.id(5, 4), "C");
    block_c.* = Block{
        .id = block_c.id,
        .content = "C",
        .left_origin = missing_block_id, // Points to non-existent block
        .right_origin = block_a.id,
        .left = null,
        .right = null,
    };
    try blocks_list.append(block_c.*);

    // Setup updates
    var updates = std.HashMap(u64, Blocks, std.hash_map.AutoContext(u64), 90).init(allocator);
    defer updates.deinit();
    try updates.put(4, &blocks_list);

    const up = Updates{
        .updates = &updates,
    };

    var us = UpdateStore.init(allocator);

    try us.apply_update(&store, up);
    // Verify that block was added to pending
    try t.expect(us.pending.blocks.count() == 1);

    // Verify that the block in pending is our block C
    const block_c_in_pending = us.pending.blocks.get(block_c.id);
    try t.expect(block_c_in_pending != null);
    try t.expect(std.mem.eql(u8, block_c_in_pending.?.content, "C"));

    // Verify document content is unchanged
    var buf = std.ArrayList(u8).init(allocator);
    try store.content(&buf);
    const content = try buf.toOwnedSlice();
    try t.expectEqualSlices(u8, "A", content);
}

================
File: .gitignore
================
.zig-cache
zig-out
.vscode
*.o

================
File: build.zig
================
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});

    const optimize = b.standardOptimizeOption(.{});

    const lib = b.addStaticLibrary(.{
        .name = "y-zig",
        // In this case the main source file is merely a path, however, in more
        // complicated build scripts, this could be a generated file.
        .root_source_file = b.path("src/root.zig"),
        .target = target,
        .optimize = optimize,
    });

    // This declares intent for the library to be installed into the standard
    // location when the user invokes the "install" step (the default step when
    // running `zig build`).
    b.installArtifact(lib);

    const exe = b.addExecutable(.{
        .name = "y-zig",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // This declares intent for the executable to be installed into the
    // standard location when the user invokes the "install" step (the default
    // step when running `zig build`).
    b.installArtifact(exe);

    // This *creates* a Run step in the build graph, to be executed when another
    // step is evaluated that depends on it. The next line below will establish
    // such a dependency.
    const run_cmd = b.addRunArtifact(exe);

    // By making the run step depend on the install step, it will be run from the
    // installation directory rather than directly from within the cache directory.
    // This is not necessary, however, if the application depends on other installed
    // files, this ensures they will be present and in the expected location.
    run_cmd.step.dependOn(b.getInstallStep());

    // This allows the user to pass arguments to the application in the build
    // command itself, like this: `zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    // This creates a build step. It will be visible in the `zig build --help` menu,
    // and can be selected like this: `zig build run`
    // This will evaluate the `run` step rather than the default, which is "install".
    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);

    // Creates a step for unit testing. This only builds the test executable
    // but does not run it.
    const lib_unit_tests = b.addTest(.{
        .root_source_file = b.path("src/root.zig"),
        .target = target,
        .optimize = optimize,
    });

    const run_lib_unit_tests = b.addRunArtifact(lib_unit_tests);

    const exe_unit_tests = b.addTest(.{
        .root_source_file = b.path("src/main.zig"),
        .test_runner = b.path("test_runner.zig"),
        .target = target,
        .optimize = optimize,
    });

    const run_exe_unit_tests = b.addRunArtifact(exe_unit_tests);

    // Similar to creating the run step earlier, this exposes a `test` step to
    // the `zig build --help` menu, providing a way for the user to request
    // running the unit tests.
    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_lib_unit_tests.step);
    test_step.dependOn(&run_exe_unit_tests.step);
}

================
File: build.zig.zon
================
.{
    .name = "y-zig",

    .version = "0.0.0",

    .dependencies = .{},

    .paths = .{
        "build.zig",
        "build.zig.zon",
        "src",
    },
}

================
File: README.md
================
### Y-Zig

Short for Yata-Zig is my project to understand CRDTs in depth.
This is inspired by the academic paper here - https://www.researchgate.net/publication/310212186_Near_Real-Time_Peer-to-Peer_Shared_Editing_on_Extensible_Data_Types

and tries to be a mini-port of the Yjs implementation of the same paper here -
https://github.com/yjs/yjs
focusing only on the text based data structure as of now.

## Roadmap

### This is a priority list arranged from high to low
Phase 1: Only focus on Single character content
- Items:
  [X] implement integration logic (local insert)
  [X] basic state vector impl for remote block integ
  [X] more tests for remote update integ
  [X] final phase 1 review
  [X] replay system (debug util) (completed phase 1 level of the util, this should be matured as need and understanding grows)
  [X] review memory

Phase 2: add support for a proper string content
- Items:
  [X] implement block splitting
  [X] marker updating everytime a new thing happens
  [X] scrap replay system

Phase 3:
  [] Deletions (only to be done when insertion is stable)
    [X] support deleting blocks and block splits
    [] support pending delete set queue and retry
        [X] jot down yjs working of basic algorithm
        [X] figure out how yjs does retrying (process pending queue at each remote integration)
        [X] how is deletion working in yjs as a state based CRDT
            - deletes are treated as statebased.
            - item marked as deleted in a field
            - item id listen in transaction, then sent in the update message (i.e. as a state message)
            - remote peer gets this update message, decodes the deleted item ids list, compares local clock with remote clock,
              checks if remote is greater, performs delete locally if yes, otherwise skip
        [] Implement delete set integration
        [] retry pending set (updates and deletes) everytime you start a remote integration
  [] state vector difference, only applying delta of changes
    - figure out how yjs calculates the difference (should simply be a vector subtraction) 
    - pseudo code for diff logic
    - implement the diff logic
    - happy flow test
    - rest of the test cases

Phase 4:
  [] make this a idiomatic zig library
      - study libghostty
      - study xit
      - make `integrate` the only way to add blocks and remove the `attach_*` functions from the code
      - only accept allocators and not other heap based structures in all init's
      - can we make the tests look a bit cleaner?
      - pondering a replay/ snapshot system

================
File: test_runner.zig
================
const std = @import("std");
const builtin = @import("builtin");

// ANSI escape codes for colors
pub const Color = struct {
    // Foreground colors
    pub const black = "\x1b[30m";
    pub const red = "\x1b[31m";
    pub const green = "\x1b[32m";
    pub const yellow = "\x1b[33m";
    pub const blue = "\x1b[34m";
    pub const magenta = "\x1b[35m";
    pub const cyan = "\x1b[36m";
    pub const white = "\x1b[37m";

    // Background colors
    pub const bg_black = "\x1b[40m";
    pub const bg_red = "\x1b[41m";
    pub const bg_green = "\x1b[42m";
    pub const bg_yellow = "\x1b[43m";
    pub const bg_blue = "\x1b[44m";
    pub const bg_magenta = "\x1b[45m";
    pub const bg_cyan = "\x1b[46m";
    pub const bg_white = "\x1b[47m";

    // Special formatting
    pub const reset = "\x1b[0m";
    pub const bold = "\x1b[1m";
    pub const dim = "\x1b[2m";
    pub const italic = "\x1b[3m";
    pub const underline = "\x1b[4m";
};

pub fn main() !void {
    const out = std.io.getStdOut().writer();

    std.fmt.format(out, "{s}Starting Tests ... {s}\n", .{ Color.yellow, Color.reset }) catch return;
    for (builtin.test_functions) |t| {
        std.fmt.format(out, "{s}RUN: {s}{s}\n", .{ Color.blue, t.name, Color.reset }) catch return;
        t.func() catch |err| {
            try std.fmt.format(out, "{s}FAIL: {!}{s}\n", .{ Color.red, err, Color.reset });
            try std.fmt.format(out, "{s}----------------------------------------------------------------------------------------------------- {s}\n", .{ Color.yellow, Color.reset });
            continue;
        };
        try std.fmt.format(out, "{s}PASS{s}\n", .{ Color.green, Color.reset });
        try std.fmt.format(out, "{s}----------------------------------------------------------------------------------------------------- {s}\n", .{ Color.yellow, Color.reset });
    }
}
